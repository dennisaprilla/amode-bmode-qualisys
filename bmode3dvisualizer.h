#ifndef BMODE3DVISUALIZER_H
#define BMODE3DVISUALIZER_H

#include <QWidget>

#include <Qt3DCore/QTransform>

#include <Qt3DExtras/Qt3DWindow>
#include <Qt3DExtras/QTextureMaterial>
#include <Qt3DExtras/QPhongMaterial>
#include <Qt3DExtras/QPlaneMesh>

#include <Qt3DRender/QMesh>
#include <Qt3DRender/QPaintedTextureImage>
#include <Qt3DRender/QTexture>
#include <Qt3DRender/QParameter>
#include <Qt3DRender/QCullFace>
#include <QPainter>

#include <opencv2/opencv.hpp>
#include <Eigen/Geometry>

#include "bmodeconnection.h"
#include "qualisysconnection.h"
#include "qualisystransformationmanager.h"


/**
 * @class PaintedTextureImage
 * @brief A class to make sure we can draw image in a QRect for B-mode mage visualization.
 *
 * For the context. There is something that prevent Qt to directly drawn a texture to QPlaneMesh.
 * Basically i ask ChatGPT to solve this problem, and gives me this. I don't really give a fuck,
 * it works, and that is what important.
 *
 */

class PaintedTextureImage : public Qt3DRender::QPaintedTextureImage {
public:
    PaintedTextureImage() : image(QImage()) {}

    void setImage(const QImage &img) {
        image = img;
        setSize(image.size());
        update(); // Trigger a repaint
    }

protected:
    void paint(QPainter *painter) override {
        QRect rect(QPoint(0, 0), size());
        painter->drawImage(rect, image);
    }

private:
    QImage image;
};

/**
 * @class Bmode3DVisualizer
 * @brief A class which handle the visualization of the 2D B-mode image in 3D environment.
 *
 * Context: The user will perform B-mode freehand scanning using this software. To make the software more intuitive,
 * it is better to visualize the real time position and orientation of the B-mode ultrasound and its image. This class
 * will visualize exactly just that.
 *
 */

class Bmode3DVisualizer : public QWidget {
    Q_OBJECT

public:

    /**
     * @brief Constructor function, requires a path to calibration config file (generated by fCal).
     */
    Bmode3DVisualizer(QWidget *parent = nullptr, QString calibconfig_path="");

public slots:

    /**
     * @brief slot function, will be called when an image is received, needs to be connected to signal from BmodeConnection::imageProcessed
     */
    void onImageReceived(const cv::Mat &image);

    /**
     * @brief slot function, will be called when transformations in a timestamp are received, needs to be connected to signal from QualisysConnection::dataReceived class
     */
    void onRigidBodyReceived(const QualisysTransformationManager &tmanager);

private:

    /**
     * @brief Initialize the 3D scence, called in the constructor
     */
    void initializeScene();

    /**
     * @brief Visualize the image, called when data from both slots function are ready
     */
    void visualizeImage();

    /**
     * @brief GET the image-to-probe transformation from the calibration configuration file (generated by fCal)
     */
    std::vector<double> getImageToProbeTransformation(const QString& filename);

    /**
     * @brief Normalize rotation matrix
     */
    void normalizeRotationMatrix(QMatrix3x3& calib_rotation);

    /**
     * @brief Convert cv::Mat to QImage, making sure everything is Qt compatible
     */
    QImage cvMatToQImage(const cv::Mat &mat);

    /**
     * @brief Convert Eigen::Isometry3d to QMatrix4x4, making sure everything is Qt compatible
     */
    QMatrix4x4 eigenToQMatrix(const Eigen::Isometry3d &eigen_mat);

    /**
     * @brief [Deprecated] Swap rotation order (and rotation hand-rule) using quaternion without involving euler angles
     *
     * This function is my attempt to swap rotation order and rotation hand-rule, similar to the current working code
     * inside eigenToQMatrix() function but in quaternion without involving euler angles conversion. It was because
     * I afraid that gimbal lock will screw the visualization.
     */
    Eigen::Quaterniond swapQuaternionOrderXYZtoZYX(const Eigen::Quaterniond& q, bool invert = false);

    /**
     * @brief Function to create arrow object, used by createAxisVector() to make the basis vector in 3d scene.
     */
    void createArrow(Qt3DCore::QEntity* rootEntity, const QColor& color, const QVector3D& rotation);

    /**
     * @brief Create axis/basis vector in 3d scene using arrow object
     */
    void createAxisVector(Qt3DCore::QEntity* rootEntity);

    /**
     * @brief [Deprecated] Create a line entity representing an axis
     */
    Qt3DCore::QEntity* createAxis(Qt3DCore::QEntity* parent, const QVector3D& start, const QVector3D& end, const QColor& color);




    // Variables for storing current image and current transformation
    cv::Mat             currentImage;                   //!< Stores the current image from BmodeConnection::imageProcessed
    Eigen::Isometry3d   currentTransform;               //!< Stores the current transformation from QualisysConnection::dataReceived, specifically B_PROBE transformation
    Qt3DCore::QTransform *currentQTransform;            //!< Same as currentTransform but with Qt3DCore::QTransform class instead of Eigen::Isometry3d

    // Variables to controling the class if both of the data are ready
    bool imageReady     = false;                        //!< Set to true if new image comes
    bool rigidbodyReady = false;                        //!< Set to true if new transformation comes

    // Variables for 3D visualization
    bool firstData      = true;                         //!< Specify that first pair of data will be visualized, we need some initialization for the first time
    Qt3DExtras::Qt3DWindow       *view;                 //!< Stores the root of the 3D environment
    Qt3DCore::QEntity            *rootEntity;           //!< Stores the root the entity which later comes with several child entities
    const double VIZ_SCALE = 0.01;                      //!< Specify the scale of the 3D visualization, default scale is in decimeter

    // Mesh for origin axis
    Qt3DCore::QEntity            *axisOriginEntity;     //!< Basis vector entity for origin
    Qt3DCore::QEntity            *axisProbeEntity;      //!< Basis vector entity for probe
    Qt3DCore::QEntity            *axisImageEntity;      //!< Basis vector entity for image

    // Mesh for Ultrasound image
    Qt3DCore::QEntity            *imageEntity;          //!< Entity for B-mode image in 3D space
    Qt3DExtras::QPlaneMesh       *planeMesh;            //!< The mesh component of imageEntity, a QPlaneMesh
    Qt3DCore::QTransform         *planeTransform;       //!< The overall transformation of plane: currentQTransform*planeCalibTransform*planeBaseTransform
    Qt3DCore::QTransform         *planeCalibTransform;  //!< Calibration transformation, comes from Configuration File that is generated by fCal software through calibration process
    Qt3DCore::QTransform         *planeBaseTransform;   //!< Base transformation of the plane, need to be adjusted first because the way QPlaneMesh oriented originialy by Qt
    Qt3DCore::QTransform         *planeOriginTransform; //!< Transformation of the origin of the plane (0,0 coordinate of image), will be applied to axisImageEntity

    PaintedTextureImage          *paintedTextureImage;  //!< Related to the texturing of the QMeshPlane for B-mode image in 3d space
    Qt3DRender::QTexture2D       *planeTexture2D;       //!< Related to the texturing of the QMeshPlane for B-mode image in 3d space
    Qt3DExtras::QTextureMaterial *planeTextureMaterial; //!< Related to the texturing of the QMeshPlane for B-mode image in 3d space

    // Mesh for Probe image
    Qt3DCore::QEntity            *probeEntity;          //!< Entity for Probe in 3D space
    Qt3DRender::QMesh            *probeMesh;            //!< The mesh component of probeEntity, a custom Mesh, QMesh
    Qt3DCore::QTransform         *probeTransform;       //!< The overall transformation of the probe: currentQTransform*probeBaseTransform
    Qt3DCore::QTransform         *probeBaseTransform;   //!< Base transformation of the probe, need to be adjusted first because the way the mesh was oriented originally from blender
    Qt3DExtras::QPhongMaterial   *probeMaterial;        //!< The default texture component of probeEntity

};

#endif // BMODE3DVISUALIZER_H
